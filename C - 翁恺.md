---
Author: Jiayuan Zhang
Date: 06/02/2022
---

# [C - 翁恺](https://www.bilibili.com/video/BV19W411B7w1?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click)

***

## 导论

* 计算机的思维方式：枚举

* 算法改进暴力枚举

* 程序的执行：

  * 解释：借助一个程序，那个程序试图理解你的程序，然后按照你的要求执行

  * 编译：借助一个程序，把你的程序翻译成机器语言，然后执行机器语言的程序

    >编译是将源程序翻译成可执行的目标代码，翻译与执行是分开的；而解释是对源程序的翻译与执行一次性完成，不生成可存储的目标代码。这只是表象，二者背后的最大区别是：对解释执行而言，程序运行时的控制权在解释器而不在用户程序；对编译执行而言，运行时的控制权在用户程序。

  * 语言本身没有解释和编译之分，只是具体执行方式不同
  * 现代两种执行方式已经没有过大的区别，各有优劣

* 现代编程语言语法上差异很小，几乎都是C-like语言

* 某些场景，例如操作系统，只能用C写

* 语言的能力/适用领域主要决定因素：
  * 库
  * 传统
  
* FORTRAN -> BCPL -> B -> C

  > C implementations give a better understanding of how the machine behaves. There is no language runtime environment or virtual machine between you and the underlying machine. 

* 指针是C的灵魂

* C的应用场景：

  * 操作系统
  * 嵌入式系统
  * 驱动程序
  * 底层驱动
  * 图形引擎、图像处理、声音效果

* Ｃ是一种工业语言
  * 开发效率＞＞学习过程
  * 开发效率＞＞开发乐趣

* 历史原因，Ｃ的编译器有很多，出现了“方言”现象

***

## 变量和常量

* 变量是一个保存数据的地方，是一段存储空间的别名
* 变量定义：`<type> <identifier>;`
* 标识符：字母，数字，下划线；第一个字符必须为字母或下划线；大小写敏感；不能用保留字
* 赋值：`=`右边的值赋给左边的变量
* 初始化：定义变量时赋值
* 没有初始化的变量，值为随机数
* C语言类型严格
* `C99`可以在任意位置定义变量；`ANSI C`只能在代码开头定义变量
* 字面量（literal）：直接写在程序里的数值（magic number）
* 常量定义：`const <type> <identifier> = <value>`
* 常量好处：物理意义；便于Debug

***

## 数据类型

* C语言的变量，必须：

  * 在使用前定义
  * 确定类型

* C以后的语言向两个方向发展：

  * C++，Java更强调类型，对类型检查严格

  * JavaScript，Python，PHP不看重类型，甚至不需要事先定义

    > 支持强类型的观点认为明确的类型有助于尽早发现程序中的简单错误
    >
    > 反对强类型的观点认为多于强调类型迫使程序员面对底层实现而非事务逻辑

* C语言需要类型，但是对类型的安全检查并不够

* | 类型       | 关键字                                      |
  | ---------- | ------------------------------------------- |
  | 整数       | `char`, `short`, `int`, `long`, `long long` |
  | 浮点数     | `float`, `double`, `long double`            |
  | 逻辑       | `bool`                                      |
  | 指针       |                                             |
  | 自定义类型 |                                             |

* 数据类型的区别：

  * 内存中占据的大小
  * 内存中的表达形式：补码，编码

* `sizeof()`：是一个运算符，给出某个**类型**或**变量**在内存中所占据的字节数

  * 静态运算符，结果在编译时刻就决定了
  * 不要在`sizeof`的括号里做运算，这些运算是不会做的

* 字面量也有数据类型

  * 默认`int, double, char, string`
  * 可以指定类型：加后缀

### 整型

* | 类型        | 字节                |
  | ----------- | ------------------- |
  | `char`      | 1                   |
  | `short`     | 2                   |
  | `int`       | 取决于编译器（CPU） |
  | `long`      | 取决于编译器（CPU） |
  | `long long` | 8                   |

* 计算机内部表达：补码

* | 类型  | 范围            |
  | ----- | --------------- |
  | `char` | -128 ~ 127     |
  | `short` | -32768 ~ 32767 |
  | `int` | -2<sup>31</sup> ~ 2<sup>31</sup> - 1 (-2147483648 ~ 2147483647) |

* `unsigned`

  * 初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位

* 整数是以纯二进制方式进行运算的

* 整数越界

* | 格式化输入输出 | 类型                     |
  | -------------- | ------------------------ |
  | `%d`           | `char, short, int, long` |
  | `%u`           | `unsigned`               |
  | `%ld`          | `long long`              |
  | `%lu`          | `unsigned long long`     |
  | `%o`           | 8进制                    |
  | `%x`           | 16进制                   |

* 以`0`开始的数字字面量是8进制；以`0x`开始的数字字面量是16进制

* 为什么有这么多整数类型？

  * 为了准确表达内存，做**底层程序**的需要
  * 历史原因

* 没有特殊需要，选择`int`

  * 现在CPU字长普遍32位或64位，一次内存读写就是一个`int`，一次计算也是一个`int`，选择更短的类型不会更快，甚至可能更慢
  * 现代编译器一般会设计内存对齐，所以更短的类型实际在内存中有可能也占据一个`int`的大小
  * `unsigned`与否只是输出的不同，内部计算是一样的

### 浮点类型

* | 类型     | 字长 | 范围                                                       | 有效数字 |
  | -------- | ---- | ---------------------------------------------------------- | -------- |
  | `float`  | 32   | $\pm(1.20 * 10^{-38} - 3.40 * 10^{38}), 0, \pm inf, nan$   | 7        |
  | `double` | 64   | $\pm(2.20 * 10^{-308} - 1.79 * 10^{308}), 0, \pm inf, nan$ | 15       |

  * `printf`输出`inf`表示超过范围的浮点数，输出`nan`表示不存在的浮点数

    ```c
    int main() {
        printf("%f\n", 12.0 / 0.0);
        printf("%f\n", -12.0 / 0.0);
        printf("%f\n", 0.0 / 0.0);
        
        return 0;
    }
    
    Output:
    inf
    -inf
    nan
    ```

* | 类型     | `scanf` | `printf` |
  | -------- | ------- | -------- |
  | `float`  | `%f`    | `%f, %e` |
  | `double` | `%lf`   | `%f, %e` |

  * `%e`：科学计数法格式
  * 字面量也可使用科学计数法格式，例：`1e-10`
  * 输出精度，例：`%.5f`，四舍五入

* 浮点类型对数据的表示是不准确的，是近似的

  * 二进制能表示的数是有限的，但数是连续的

* 浮点运算没有精度

  * 不能直接比较
  * 误差会累积
  * 转而使用整型解决实际问题

  ```c
  int main() {
      float a, b, c;
      
      a = 1.345f;
      b = 1.123f;
      c = a + b;
      if(c == 2.468)
          printf("Equal!\n");
      else
          printf("Not equal! c = %.10f, or %f\n", c, c);
      
      return 0;
  }
  
  // f1 == f2 可能失败
  // fabs(f1 - f2) < 1e-12 来比较
  ```

* 浮点数内部表达：编码

* 浮点数在计算时是由专用的硬件部件实现的

* 没有特殊需要，使用`double`

### 字符类型

* `char`既是整型，也是字符型
* 格式化输入输出：`%c`
* 字符字面量：`''`表示
* ASCII码

#### 转义字符-Escape character

* 用来表达无法打印出来的控制字符或特殊字符，由`\`开头，后面跟上一个字符

* | 常用转义字符 | 意义           |
  | ------------ | -------------- |
  | `\b`         | 回退一格       |
  | `\t`         | 到下一个表格位 |
  | `\n`         | 换行           |
  | `\r`         | 回车           |
  | `\"`         | 双引号         |
  | `\'`         | 单引号         |
  | `\\`         | 反斜杠本身     |

  * 回退一般不代表删除
  * 制表位：每行的固定位置，而不是固定大小的字符数量
  * 换行实际上是回车和换行两个动作

### 类型转换

#### 自动类型转换

* 当运算符两边出现不一致的类型时，会自动转换成较大的类型
* `char -> short -> int -> long -> long long`
* `int -> float -> double`
* 对于`printf`，任何小于`int`的类型会被转换成`int`，`float`会被转换成`double`
* `scanf`不会

#### 强制类型转换

* `(type) value`
* 注意安全性
* 只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型
* 强制类型转换的优先级高于四则运算

### 逻辑类型

* C语言原本是没有`bool`类型的
* `#include <stdbool.h>`
* 之后可以使用`true`，`false`
* 实际上是整型，`1`和`0`

***

## 运算

* 表达式：一系列运算符和操作数的组合

* 运算符（operator）

  | 运算类型 | 运算符          |
  | -------- | --------------- |
  | 四则     | + - * / % ()    |
  | 关系     | < > <= >= == != |
  | 逻辑     | && \|\| !       |
  | 位       | & \| ^ >> << ~  |
  | 单目     | + -             |
  | 赋值     | =               |
  | 复合赋值 | += -= *= /= %=  |
  | 递增递减 | ++ --           |
  | 条件     | ? :             |
  | 逗号     | ,               |

* 操作数（operand）

### 四则

* 整型除法舍弃小数部分
* 浮点数不能取余
* 优先级：正负 > 乘除 > 取余 > 加减 > 赋值

### 赋值

* 赋值也是运算，也有结果
* 例：`a = 6`的结果是`6`
* 自右向左结合

### 递增递减

* 前缀：`a++`结果是`a`加`1`以前的值
* 后缀：`++a`结果是`a`加`1`以后的值
* `a + 1`是附作用

### 关系

* 比较结果：逻辑值真1假0
* 优先级比算术低，比赋值高
* 连续的关系运算从左向右执行

### 逻辑

* 短路法则：逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算

### 逗号

* 逗号用来连接两个表达式，并以右边的表达式的值作为它的结果
* 逗号运算符的优先级是最低的
* 主要在`for`中使用

***

## 流程控制

### 选择

#### If - else

* 二路分支
* 嵌套
* 级联
* else总是和最近的if匹配
* “单一出口”原则

#### Switch

* 多路分支
* 控制表达式只能是整数型
* `case`常量可以是常数，也可以是常数计算的表达式
* `case`判断代码块内执行的开始
  * 合并分支
* `break`语句，没有`break`会顺序向下执行
* 默认情况执行`default`下的语句
* `default`不是必须但是最好有

### 循环

#### While

* 先判断条件再执行循环体

#### Do while

* 先执行一次循环体再判断条件

#### For

* 如果有固定次数，用`for`；如果必须执行一次，用`do while`；其他情况用`while`

* 循环控制：`break`，`continue`；最近匹配原则，针对当前循环

  > `break`对`if-else`不起作用

* 循环嵌套

* 跳出多重循环：`goto`

* 给定条件的整数集：枚举 + 剔除

***

## 函数

* 函数是可以重复利用的代码块，接受零个或多个参数，做一件事情，并返回零个或一个值
* 函数定义
  * 函数头：返回类型 函数名 参数列表
  * 函数体
* 函数调用：`函数名(参数值);`
  * 执行 -> 调用函数 -> 执行调用函数 -> 返回 -> 恢复执行
* 函数返回：`return`
  * `return`停止函数的执行，并返回一个值
  * `return;`, `return exp;`
* `void`
  * `void`不能用于定义变量
  * 用于函数定义，表示无返回值或无参数
  * `type func();`表示接受任意多的参数
* 函数的先后关系
  * C的编译器自上而下顺序分析
  * 调用函数需要先声明或定义
  * 声明定义要一致
* 参数传递
  * 值传递
  * 调用函数时给的值与参数类型不匹配是C语言传统上最大的漏洞，编译器会隐式地进行类型转换
  * 每个函数有自己的变量空间，参数也位于这个空间中
* 变量分类
  * 局部（本地）变量：函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数这次运行所独有的，称作局部变量
    * 定义在函数内部的变量，参数
    * 定义在语句块内的变量
    * 只能在当前**块**中访问使用
    * 块外定义变量在块内仍然有效
    * 本地变量**不会被默认初始化**
    * 参数在进入函数时会初始化
  * 全局变量：定义在函数外面的变量
    * 没有初始化的全局变量会得到`0`值
    * 指针会得到`null`值
    * 只能用编译时已知的值来初始化全局变量
    * 全局变量初始化发生在`main`函数之前
    * 工程中，全局变量通常以`g`作为前缀命名
  * 同名变量
    * 不同块中的局部变量可以同名
    * 同一块中的局部变量不可以同名
    * 块内同名变量覆盖块外同名变量
  * 静态变量：`static`
    * 静态本地变量
      * 作用域：块内；生命期：程序生命期
      * 静态本地变量只会在第一次进入函数时初始化一次
      * 离开函数时，静态本地变量会继续存在并保持其值
      * 特殊的全局变量，创建于全局数据区
    * 静态全局变量
      * 作用域：文件作用域；生命期：程序生命期
* 作用域：变量定义后的可访问范围
  * 局部变量：定义开始到代码块结束
  * 全局变量：程序的任何地方
* 生命期：变量从创建到销毁的时间
  * 局部变量：进入作用域时创建，离开作用域时自动销毁
  * 全局变量：程序开始运行时创建，程序结束时自动销毁
* 调用函数里的`,`不是运算符
* C语言不允许函数嵌套定义，可以放声明
* C语言程序的入口：`main`函数
  * `main()`是应用程序与操作系统的“约定”

***

## 数组

* 数组是相同数据类型变量的有序集合
* 数组定义：`<type> identifier[size];`
* 数组类型：`<type>[size]`
* 元素数量必须是整数，必须是编译时刻确定的字面量
  * **`C99`之后可以使用变量**
* 数组在计算机内是一片连续的内存
* 数组一旦创建，**不能改变大小**
* 数组访问：`identifier[index]`
  * 数组下标从`0`开始
  * 可以使用变量作为下标
  * 编译器和运行环境都不会检查数组下标是否越界，无论读写
  * 一旦程序运行，数组越界**可能**造成问题，导致程序崩溃
  * 不同机器上无法复现程序的一大问题：没有考虑数组越界
* 长度为0数组可以定义，但是无用，自然越界
* 数组初始化
  1. `<type> identifier[N] = {v0, v1, ..., vn-1};` 不初始化是随机值
  2. 自动确定数组大小：`<type> identifier[] = {v0, v1, ..., vn-1};`
  3. 部分初始化：`<type> identifier[N] = {[0] = 2, [2] = 3, 6, };`
     * 用`[n]`在初始化数据中给出定位
     * 没有定位的数据姐在前面的位置后面
     * 其他位置补零
     * 适合初始数据稀疏的数组
* 数组大小：`sizeof(identifier)`
* 数组个数：`sizeof(identifier) / sizeof(identifier[0])`
* 数组变量本身不能被赋值。要想拷贝一个数组，只能遍历
* 数组作为函数参数时，往往必须再用另一个参数来传入数组的大小
* 数组变量本身表达地址，无需用`&`取地址；数组单元表达的是变量
* 二维数组
  * `<type> identifier[M][N];`
  * 通常理解为M行N列的矩阵，或者M个大小为N的一维数组
  * 二维数组初始化列数必须给出，行数可以自动确定
  * 检查行
  * 检查列
  * 检查对角线，反对角线

***

## 指针

* `&`运算符：获得变量的地址，他的操作数必须是变量

  * 格式化输出：`%p`
  * 地址的大小与编译器有关
  * 内存地址本质上是一个无符号整数

* 指针变量：保存地址的变量

  * 普通变量放的是值
  * 禁止将普通数值当作地址赋值给指针变量，除非你知道自己在干什么

* 指针定义：`<type> *p;`或者`<type>* p;`

  * `<type>`决定**访问内存时的长度范围**

    > 个人理解，指针类型也是个数据类型

* 访问指针地址上的变量：`*p`

  * 可以做右值也可以做左值
  * 没有赋值前不要访问

* 指针应用场景

  * 交换变量
  * 函数返回多个值，某些值就只能通过指针返回
    * 传入的参数实际上是需要保存结果的变量的地址
  * 函数返回运算的状态`(0, 1)`，结果通过指针返回
    * 可能会出错的运算
    * 后续语言（`C++`，`Java`）采用了异常机制来解决这个问题

* 指针与数组

  * 函数参数表中的数组实际上是指针，但是可以用数组的运算符`[]`进行计算

  * `void func(int a[]);`和`void func(int* a);`作为函数原型是等价的

  * **数组类型和指针类型不是等价的**

  * `[]`运算符可以对数组做，也可以对指针做

  * `*`运算符可以对指针做，也可以对数组做

  * `array`, `&array`, `&array[0]`区别

    * `array`可以当作一个**指针常量**，指向**数组第一个元素**

      * 两种情况数组名不是用指针常量来表示
        1. `sizeof(array)`：返回整个数组的长度，而不是指针的长度
        2. `&array`：返回一个指向数组的指针，而不是一个指向指针的指针

    * `&array`是一个**指针值**，指向**整个数组**

    * `&array[0]`是一个**指针值**，指向**数组的第一个元素**

    * 三者值相同，但意义不同

      > [这是一个很好的解释](https://blog.csdn.net/jingzi123456789/article/details/66478310)

    ```c
    int main() {
        int array[5] = {0};
    
        // ERROR
        // Because array is a const pointer
        // array = 5345454;
    
    	printf("        array = %p\n", array);
    	printf("       &array = %p\n", &array);
    	printf("    &array[0] = %p\n", &array[0]);
    	printf("    array + 1 = %p\n", array + 1);
    	printf("&array[0] + 1 = %p\n", &array[0] + 1);
    	printf("   &array + 1 = %p\n", &array + 1);
    
    	printf("\n");
    
    	printf(" sizeof(array) = %d\n", sizeof(array));
    	printf("sizeof(&array) = %d\n", sizeof(&array));
    
    	printf("\n");
    
        return 0;
    }
    
    Output:
            array = 0061FEEC
           &array = 0061FEEC
        &array[0] = 0061FEEC
        array + 1 = 0061FEF0
    &array[0] + 1 = 0061FEF0
       &array + 1 = 0061FF00
    
    sizeof(array) = 20
    sizeof(&array) = 4
    ```

* 指针与`const`

  * 
